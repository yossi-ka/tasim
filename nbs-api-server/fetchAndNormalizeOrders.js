/**
 * NBS Orders and Products Fetcher & Normalizer
 * 
 * This script fetches orders and products from the NBS API, normalizes the data
 * so each order contains an array of its associated products, and writes the
 * result to a JSON file (orders_with_products.json).
 * 
 * Usage:
 * - Run directly: node fetchAndNormalizeOrders.js
 * - Import as module: const { fetchAndNormalizeOrders } = require('./fetchAndNormalizeOrders.js')
 * 
 * Output:
 * - Creates orders_with_products.json in the same directory
 * - Prints summary statistics to console
 */

const axios = require('axios');
const XLSX = require('xlsx');
const fs = require('fs');
const path = require('path');

const BASE_NBS_URL = "https://sales-v2.nbs-app.net/api/crm/";

// ◊§◊ï◊†◊ß◊¶◊ô◊î ◊ú◊ß◊ë◊ú◊™ ◊ò◊ï◊ß◊ü ◊û-NBS
const getNbsToken = async () => {
    console.log('üîê Starting authentication process...');

    const userName = "naftali";
    const password = "naftali2015";

    if (!userName || !password) {
        console.error('‚ùå NBS credentials are missing');
        throw new Error('NBS credentials are not set');
    }

    const data = JSON.stringify({
        "email": userName,
        "username": userName,
        "password": password
    });

    const config = {
        method: 'post',
        maxBodyLength: Infinity,
        url: BASE_NBS_URL + 'auth/login/',
        headers: {
            'Accept': 'application/json, text/plain, */*',
            'Origin': 'https://crm.shoppi.co.il',
            'Referer': 'https://crm.shoppi.co.il/',
            'Sec-Fetch-Site': 'cross-site',
            'Sec-Fetch-Mode': 'cors',
            'User-Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Mobile Safari/537.36',
            'Content-Type': 'application/json'
        },
        data: data
    };

    try {
        const res = await axios.request(config);

        if (res.status !== 200 || res.data.status !== 'success') {
            console.error('‚ùå Authentication failed:', res.status, res.statusText);
            throw new Error(`Failed to get token: ${res.status} ${res.statusText}`);
        }

        console.log('üéâ Authentication successful! Token received.');
        return res.data.data.access;

    } catch (error) {
        console.error('üí• Error during authentication:', error.message);
        if (error.response) {
            console.error('üì• Error response status:', error.response.status);
            console.error('üì• Error response data:', error.response.data);
        }
        throw error;
    }
};

// ◊§◊ï◊†◊ß◊¶◊ô◊î ◊ú◊©◊ú◊ô◊§◊™ ◊†◊™◊ï◊†◊ô◊ù ◊û-NBS
const getNbsOrders = async (token, filters, exportType) => {
    console.log(`üì¶ Fetching orders with exportType: ${exportType}`);
    
    const config = {
        method: 'get',
        maxBodyLength: Infinity,
        url: `${BASE_NBS_URL}order/report/export-xlsx/?filters=${filters}&sort=%7B%22sortBy%22:%22%22,%22sortDir%22:%22desc%22%7D&exportType=${exportType}`,
        headers: {
            'Accept': 'application/json, text/plain, */*',
            'Origin': 'https://crm.shoppi.co.il',
            'Referer': 'https://crm.shoppi.co.il/',
            'Sec-Fetch-Site': 'cross-site',
            'Sec-Fetch-Mode': 'cors',
            'User-Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Mobile Safari/537.36',
            'Authorization': 'Bearer ' + token
        },
        responseType: 'arraybuffer'
    };

    try {
        const res = await axios.request(config);

        if (res.status !== 200) {
            console.error('‚ùå Failed to fetch orders:', res.status, res.statusText);
            throw new Error(`Failed to get orders: ${res.status} ${res.statusText}`);
        }

        console.log('‚úÖ Orders data received successfully');
        return res.data;

    } catch (error) {
        console.error('üí• Error fetching orders:', error.message);
        if (error.response) {
            console.error('üì• Error response status:', error.response.status);
            console.error('üì• Error response headers:', error.response.headers);
        }
        throw error;
    }
};

// ◊§◊ï◊†◊ß◊¶◊ô◊î ◊ú◊§◊®◊°◊ï◊® Excel ◊úJSON
const parseExcelToJson = (excelResponse, headerMapping, rowProcessor = null) => {
    console.log('üìä Starting Excel parsing...');

    let workbook;
    if (excelResponse instanceof ArrayBuffer) {
        workbook = XLSX.read(excelResponse, { type: 'array' });
    } else if (excelResponse instanceof Uint8Array) {
        workbook = XLSX.read(excelResponse, { type: 'array' });
    } else {
        workbook = XLSX.read(new Uint8Array(excelResponse), { type: 'array' });
    }

    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];

    console.log('üìã Excel workbook parsed, processing sheet...');

    const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
        header: 1,
        defval: '',
        raw: false
    });

    if (jsonData.length === 0) {
        console.log('‚ö†Ô∏è No data found in Excel file');
        return [];
    }

    const headers = jsonData[0];
    console.log('üìã Headers found:', headers);

    console.log(`üîÑ Processing ${jsonData.length - 1} data rows...`);
    const structuredData = [];
    
    for (let i = 1; i < jsonData.length; i++) {
        const row = jsonData[i];
        const rowData = {};

        for (let headerIndex = 0; headerIndex < headers.length; headerIndex++) {
            const header = headers[headerIndex];
            const fieldName = headerMapping[header];
            if (fieldName && row[headerIndex] !== undefined && row[headerIndex] !== '') {
                rowData[fieldName] = row[headerIndex];
            }
        }

        let processedRow;
        if (rowProcessor && typeof rowProcessor === 'function') {
            processedRow = rowProcessor(rowData, row, i - 1);
        } else {
            processedRow = rowData;
        }

        if (processedRow && Object.keys(processedRow).length > 0) {
            structuredData.push(processedRow);
        }

        if (i % 500 === 0) {
            console.log(`üìä Processed ${i - 1}/${jsonData.length - 1} rows`);
        }
    }

    console.log(`‚úÖ Excel parsing completed. Total rows processed: ${structuredData.length}`);
    return structuredData;
};

// ◊§◊ï◊†◊ß◊¶◊ô◊î ◊ú◊©◊ú◊ô◊§◊™ ◊î◊ñ◊û◊†◊ï◊™
const getOrders = async (token) => {
    try {
        const filtersObject = {
            searchTerm: "",
            saleIds: [],
            branchIds: [],
            paymentMethod: [],
            status: ["paid"],
            createdVia: [],
            shippingMethod: [],
            sumRange: {
                from: 0,
                to: 0
            },
            updatedRange: {
                unit: "days",
                amount: 1
            }
        };

        const filters = encodeURIComponent(JSON.stringify(filtersObject));

        let mainOrders;
        let retryCount = 0;
        const maxRetries = 3;

        while (retryCount < maxRetries) {
            try {
                mainOrders = await getNbsOrders(token, filters, "basic");
                break;
            } catch (error) {
                retryCount++;
                console.log(`‚ö†Ô∏è API call failed (attempt ${retryCount}/${maxRetries}):`, error.message);

                if (retryCount >= maxRetries) {
                    throw error;
                }

                const waitTime = retryCount * 2000;
                console.log(`‚è≥ Waiting ${waitTime}ms before retry...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));

                token = await getNbsToken();
            }
        }

        const headerMapping = {
            "◊û◊°◊§◊® ◊î◊ñ◊û◊†◊î": "nbsOrderId",
            "◊©◊ù ◊§◊®◊ò◊ô": "firstName",
            "◊©◊ù ◊û◊©◊§◊ó◊î": "lastName",
            "◊™.◊ñ": "idNumber",
            "◊ò◊ú◊§◊ï◊ü": "phones",
            "◊ê◊û◊ô◊ô◊ú": "email",
            "◊¢◊ô◊®": "city",
            "◊õ◊™◊ï◊ë◊™": "street",
            "◊™◊ê◊®◊ô◊ö ◊ë◊ô◊¶◊ï◊¢": "openedAt",
            "◊™◊ê◊®◊ô◊ö ◊¢◊ì◊õ◊ï◊ü": "closedAt",
            "◊°◊ò◊ò◊ï◊°": "nbsOrderStatus",
            "◊ê◊ï◊§◊ü ◊™◊©◊ú◊ï◊ù": "paymentMethod",
            "◊°◊î\"◊õ": "totalPrice",
            "◊î◊¢◊®◊î": "orderNote",
            "◊û◊ô◊ì◊¢ ◊†◊ï◊°◊£": "moreInfo"
        };

        const orderRowProcessor = (orderData) => {
            if (!orderData.nbsOrderId) {
                return null;
            }

            // ◊¢◊ô◊ë◊ï◊ì ◊û◊°◊§◊®◊ô ◊ò◊ú◊§◊ï◊ü
            if (orderData.phones && typeof orderData.phones === 'string') {
                orderData.phones = orderData.phones.split(' ').filter(phone => phone.trim() !== '');
            }

            // ◊¢◊ô◊ë◊ï◊ì ◊™◊ê◊®◊ô◊õ◊ô◊ù
            ['openedAt', 'closedAt'].forEach(dateField => {
                if (orderData[dateField]) {
                    if (typeof orderData[dateField] === 'number') {
                        orderData[dateField] = new Date((orderData[dateField] - 25569) * 86400 * 1000);
                    } else if (typeof orderData[dateField] === 'string') {
                        orderData[dateField] = new Date(orderData[dateField]);
                    }
                }
            });

            // ◊¢◊ô◊ë◊ï◊ì ◊û◊°◊§◊®◊ô◊ù
            ['totalPrice', 'nbsOrderId'].forEach(numberField => {
                if (orderData[numberField] && !isNaN(orderData[numberField])) {
                    orderData[numberField] = Number(orderData[numberField]);
                }
            });

            return orderData;
        };

        const structuredData = parseExcelToJson(mainOrders, headerMapping, orderRowProcessor);

        console.log('Parsed Orders Data:');
        console.log(`Total orders parsed: ${structuredData.length}`);

        return structuredData;

    } catch (error) {
        console.error('üí• Error during order processing:', error.message);
        throw error;
    }
};

// ◊§◊ï◊†◊ß◊¶◊ô◊î ◊ú◊©◊ú◊ô◊§◊™ ◊û◊ï◊¶◊®◊ô◊ù ◊©◊ú ◊î◊ñ◊û◊†◊ï◊™
const getOrderProducts = async (token, orderIds = null) => {
    try {
        const filtersObject = {
            searchTerm: "",
            saleIds: [],
            branchIds: [],
            paymentMethod: [],
            status: ["paid"],
            createdVia: [],
            shippingMethod: [],
            sumRange: {
                from: 0,
                to: 0
            },
            updatedRange: {
                unit: "days",
                amount: 1
            }
        };

        const filters = encodeURIComponent(JSON.stringify(filtersObject));

        let mainOrders;
        let retryCount = 0;
        const maxRetries = 3;

        while (retryCount < maxRetries) {
            try {
                mainOrders = await getNbsOrders(token, filters, "weights");
                break;
            } catch (error) {
                retryCount++;
                console.log(`‚ö†Ô∏è API call failed (attempt ${retryCount}/${maxRetries}):`, error.message);

                if (retryCount >= maxRetries) {
                    throw error;
                }

                const waitTime = retryCount * 2000;
                console.log(`‚è≥ Waiting ${waitTime}ms before retry...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));

                token = await getNbsToken();
            }
        }

        const headerMapping = {
            "◊û◊°◊§◊® ◊î◊ñ◊û◊†◊î": "nbsOrderId",
            "◊§◊®◊ô◊ò": "productName",
            "◊û◊©◊ß◊ú ◊§◊®◊ô◊ò": "weights",
            "◊û◊ó◊ô◊® ◊§◊®◊ô◊ò": "price"
        };

        const orderProductRowProcessor = (orderData) => {
            if (!orderData.nbsOrderId || !orderData.productName) {
                return null;
            }

            ['nbsOrderId', 'weights', 'price'].forEach(numberField => {
                if (orderData[numberField] && !isNaN(orderData[numberField])) {
                    orderData[numberField] = Number(orderData[numberField]);
                }
            });

            return orderData;
        };

        const parsedData = parseExcelToJson(mainOrders, headerMapping, orderProductRowProcessor);

        // ◊°◊ô◊†◊ï◊ü ◊ú◊§◊ô ◊û◊°◊§◊®◊ô ◊î◊ñ◊û◊†◊î ◊°◊§◊¶◊ô◊§◊ô◊ô◊ù ◊ê◊ù ◊†◊ì◊®◊©
        let filteredData = parsedData;
        if (orderIds && orderIds.length > 0) {
            const orderIdSet = new Set(orderIds);
            filteredData = parsedData.filter(item => orderIdSet.has(item.nbsOrderId));
            console.log(`üîç Filtered products from ${parsedData.length} to ${filteredData.length} based on order IDs`);
        }

        // ◊†◊®◊û◊ï◊ú ◊†◊™◊ï◊†◊ô◊ù - ◊ß◊ô◊ë◊ï◊• ◊ú◊§◊ô ◊î◊ñ◊û◊†◊î ◊ï◊û◊ï◊¶◊®
        console.log('üîÑ Starting data normalization...');
        const productGroups = new Map();

        for (let i = 0; i < filteredData.length; i++) {
            const row = filteredData[i];
            const key = `${row.nbsOrderId}-${row.productName}`;

            if (productGroups.has(key)) {
                const existing = productGroups.get(key);
                if (row.weights && existing.weights !== undefined) {
                    existing.weights += row.weights;
                    existing.quantityOrWeight = existing.weights;
                } else if (!row.weights && existing.quantity !== undefined) {
                    existing.quantity += 1;
                    existing.quantityOrWeight = existing.quantity;
                } else if (row.weights && existing.quantity !== undefined) {
                    delete existing.quantity;
                    existing.weights = row.weights;
                    existing.quantityOrWeight = row.weights;
                } else if (!row.weights && existing.weights !== undefined) {
                    existing.quantityOrWeight = existing.weights;
                }
            } else {
                const newProduct = { ...row };
                if (row.weights) {
                    newProduct.quantityOrWeight = row.weights;
                } else {
                    newProduct.quantity = 1;
                    newProduct.quantityOrWeight = 1;
                }
                productGroups.set(key, newProduct);
            }

            if (i % 5000 === 0) {
                console.log(`üìä Normalized ${i}/${filteredData.length} products`);
            }
        }

        // ◊î◊û◊®◊î ◊ú◊û◊¢◊®◊ö ◊ï◊†◊ô◊ß◊ï◊ô
        const normalizedData = [];
        productGroups.forEach(product => {
            delete product.quantity;
            normalizedData.push(product);
        });

        console.log('‚úÖ Data normalization completed');
        console.log(`Total normalized products: ${normalizedData.length}`);

        return normalizedData;

    } catch (error) {
        console.error('üí• Error during order products processing:', error.message);
        throw error;
    }
};

// ◊î◊§◊ï◊†◊ß◊¶◊ô◊î ◊î◊®◊ê◊©◊ô◊™ - ◊©◊ú◊ô◊§◊î, ◊†◊®◊û◊ï◊ú ◊ï◊©◊ú◊ô◊ó◊î ◊ú◊©◊®◊™
const fetchAndNormalizeOrders = async () => {
    try {
        console.log('üöÄ Starting NBS data fetch and normalization...');

        // ◊ß◊ë◊ú◊™ ◊ò◊ï◊ß◊ü
        const token = await getNbsToken();

        // ◊©◊ú◊ô◊§◊™ ◊î◊ñ◊û◊†◊ï◊™
        console.log('üìã Fetching orders...');
        const orders = await getOrders(token);

        if (orders.length === 0) {
            console.log('‚ö†Ô∏è No orders found');
            return [];
        }

        // ◊ß◊ë◊ú◊™ ◊û◊°◊§◊®◊ô ◊î◊ñ◊û◊†◊ï◊™
        const orderIds = orders.map(order => order.nbsOrderId).filter(id => id);
        console.log(`üìä Found ${orderIds.length} order IDs`);

        // ◊©◊ú◊ô◊§◊™ ◊û◊ï◊¶◊®◊ô◊ù
        console.log('üì¶ Fetching order products...');
        const orderProducts = await getOrderProducts(token, orderIds);

        // ◊ô◊¶◊ô◊®◊™ ◊û◊ô◊§◊ï◊ô ◊û◊ï◊¶◊®◊ô◊ù ◊ú◊§◊ô ◊î◊ñ◊û◊†◊î
        console.log('üîÑ Creating orders with products structure...');
        const productsByOrder = new Map();

        orderProducts.forEach(product => {
            const orderId = product.nbsOrderId;
            if (!productsByOrder.has(orderId)) {
                productsByOrder.set(orderId, []);
            }
            productsByOrder.get(orderId).push({
                productName: product.productName,
                quantityOrWeight: product.quantityOrWeight,
                weights: product.weights,
                price: product.price
            });
        });

        // ◊©◊ô◊ú◊ï◊ë ◊î◊ñ◊û◊†◊ï◊™ ◊¢◊ù ◊û◊ï◊¶◊®◊ô◊ù
        const ordersWithProducts = orders.map(order => {
            const products = productsByOrder.get(order.nbsOrderId) || [];
            return {
                ...order,
                products: products
            };
        });

        console.log('‚úÖ Data normalization completed successfully!');
        console.log(`üìä Total orders with products: ${ordersWithProducts.length}`);
        console.log(`üì¶ Total products across all orders: ${orderProducts.length}`);

        // ◊©◊ú◊ô◊ó◊™ ◊î◊†◊™◊ï◊†◊ô◊ù ◊ú◊ê◊†◊ì◊§◊ï◊ô◊†◊ò Firebase Function
        try {
            console.log('\nüöÄ Sending data to Firebase Function...');
            const response = await axios.post(
                'https://us-central1-kanfei-nesharim.cloudfunctions.net/test3',
                ordersWithProducts,
                {
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    timeout: 300000 // 5 minutes timeout
                }
            );
            console.log(`‚úÖ Data successfully sent to Firebase Function`);
            console.log(`ÔøΩ Response status: ${response.status}`);
            console.log(`üìã Response data: ${response.data}`);
        } catch (sendError) {
            console.error(`\n‚ùå Error sending data to Firebase Function: ${sendError.message}`);
            if (sendError.response) {
                console.error(`ÔøΩ Response status: ${sendError.response.status}`);
                console.error(`üì• Response data: ${sendError.response.data}`);
            }
            // ◊ë◊û◊ß◊®◊î ◊©◊ú ◊õ◊©◊ú, ◊†◊©◊û◊ï◊® ◊í◊ù ◊ú◊ß◊ï◊ë◊• ◊û◊ß◊ï◊û◊ô ◊õ◊í◊ô◊ë◊ï◊ô
            console.log('\nüíæ Saving data locally as backup...');
            const outputPath = path.join(__dirname, 'orders_with_products_backup.json');
            fs.writeFileSync(outputPath, JSON.stringify(ordersWithProducts, null, 2), 'utf8');
            console.log(`üíæ Backup saved to: ${outputPath}`);
            throw sendError;
        }

        return ordersWithProducts;

    } catch (error) {
        console.error('üí• Error in fetchAndNormalizeOrders:', error.message);
        throw error;
    }
};

// ◊ê◊ù ◊î◊ß◊ï◊ë◊• ◊û◊ï◊®◊• ◊ô◊©◊ô◊®◊ï◊™
if (require.main === module) {
    fetchAndNormalizeOrders()
        .then(result => {
            console.log(`\n‚úÖ Script completed successfully with ${result.length} orders`);
            // ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊ï◊™
            const ordersWithProducts = result.filter(order => order.products && order.products.length > 0);
            const ordersWithoutProducts = result.filter(order => !order.products || order.products.length === 0);
            const totalProducts = result.reduce((sum, order) => sum + (order.products ? order.products.length : 0), 0);
            console.log('\nüìä Summary:');
            console.log(`- Total orders: ${result.length}`);
            console.log(`- Orders with products: ${ordersWithProducts.length}`);
            console.log(`- Orders without products: ${ordersWithoutProducts.length}`);
            console.log(`- Total products: ${totalProducts}`);
            process.exit(0);
        })
        .catch(error => {
            console.error('\n‚ùå Script failed:', error.message);
            process.exit(1);
        });
}

// ◊ô◊ô◊¶◊ï◊ê ◊î◊§◊ï◊†◊ß◊¶◊ô◊ï◊™ ◊ú◊©◊ô◊û◊ï◊© ◊ó◊ô◊¶◊ï◊†◊ô
module.exports = {
    fetchAndNormalizeOrders,
    getNbsToken,
    getOrders,
    getOrderProducts,
    // normalizeOrdersWithProducts
};
